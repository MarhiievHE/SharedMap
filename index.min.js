"use strict";const UINT32_MAX=4294967295;const UINT32_UNDEFINED=4294967295;function _hash(str){var l=str.length,h=17^l,i=0,k;while(l>=4){k=str.charCodeAt(i)&255|(str.charCodeAt(++i)&255)<<8|(str.charCodeAt(++i)&255)<<16|(str.charCodeAt(++i)&255)<<14;k=(k&65535)*1540483477+(((k>>>16)*1540483477&65535)<<16);k^=k>>>14;k=(k&65535)*1540483477+(((k>>>16)*1540483477&65535)<<16);h=(h&65535)*1540483477+(((h>>>16)*1540483477&65535)<<16)^k;l-=4;++i}switch(l){case 3:h^=(str.charCodeAt(i+2)&255)<<16;case 2:h^=(str.charCodeAt(i+1)&255)<<8;case 1:h^=str.charCodeAt(i)&255;h=(h&65535)*1540483477+(((h>>>16)*1540483477&65535)<<16)}h^=h>>>13;h=(h&65535)*1540483477+(((h>>>16)*1540483477&65535)<<16);h^=h>>>15;return h>>>0}function align32(v){return(v&0xffffffffffffc)+(v&3?4:0)}const META={maxSize:0,keySize:1,objSize:2,length:3};const LOCK={SHAREDREAD:0,READLOCK:1,READERS:2,SHAREDWRITE:3,WRITELOCK:4,WRITERS:5};class Deadlock extends Error{constructor(...params){super(...params)}}class SharedMap{constructor(maxSize,keySize,objSize){maxSize=align32(maxSize);keySize=align32(keySize);objSize=align32(objSize);if(!(maxSize>0&&keySize>0&&objSize>0))throw new RangeError("maxSize, keySize and objSize must be positive numbers");this.storage=new SharedArrayBuffer(Object.keys(META).length*Uint32Array.BYTES_PER_ELEMENT+(keySize+objSize)*maxSize*Uint16Array.BYTES_PER_ELEMENT+maxSize*Uint32Array.BYTES_PER_ELEMENT+Math.ceil(maxSize/32)*Int32Array.BYTES_PER_ELEMENT+Object.keys(LOCK).length*Int32Array.BYTES_PER_ELEMENT);let offset=0;this.meta=new Uint32Array(this.storage,offset,Object.keys(META).length);offset+=this.meta.byteLength;this.meta[META.maxSize]=maxSize;this.meta[META.keySize]=keySize;this.meta[META.objSize]=objSize;this.meta[META.length]=0;this.keysData=new Uint16Array(this.storage,offset,this.meta[META.keySize]*this.meta[META.maxSize]);offset+=this.keysData.byteLength;this.valuesData=new Uint16Array(this.storage,offset,this.meta[META.objSize]*this.meta[META.maxSize]);offset+=this.valuesData.byteLength;this.chaining=new Uint32Array(this.storage,offset,this.meta[META.maxSize]);offset+=this.chaining.byteLength;this.linelocks=new Int32Array(this.storage,offset,Math.ceil(maxSize/32));offset+=this.linelocks.byteLength;this.maplock=new Int32Array(this.storage,offset,Object.keys(LOCK).length);this.stats={set:0,delete:0,collisions:0,rechains:0,get:0,deadlock:0}}get length(){return Atomics.load(this.meta,META.length)}get size(){return this.meta[META.maxSize]}_lock(l){while(true){let state;state=Atomics.exchange(this.maplock,l,1);if(state==0)return;Atomics.wait(this.maplock,l,state)}}_unlock(l){const state=Atomics.exchange(this.maplock,l,0);if(state==0)throw new Error("maplock desync "+l);Atomics.notify(this.maplock,l)}_lockLine(pos){const bitmask=1<<pos%32;const index=Math.floor(pos/32);while(true){const state=Atomics.or(this.linelocks,index,bitmask);if((state&bitmask)==0)return pos;Atomics.wait(this.linelocks,index,state)}}_unlockLine(pos){const bitmask=1<<pos%32;const notbitmask=~bitmask&UINT32_MAX;const index=Math.floor(pos/32);const state=Atomics.and(this.linelocks,index,notbitmask);if((state&bitmask)==0)throw new Error("linelock desync "+pos);Atomics.notify(this.linelocks,index)}_lockLineSliding(oldLock,newLock){if(newLock<=oldLock)throw new Deadlock;this._lockLine(newLock);this._unlockLine(oldLock);return newLock}lockExclusive(){this._lock(LOCK.READLOCK)}unlockExclusive(){this._unlock(LOCK.READLOCK)}_lockSharedRead(){this._lock(LOCK.SHAREDREAD);if(++this.maplock[LOCK.READERS]==1)this._lock(LOCK.READLOCK);this._unlock(LOCK.SHAREDREAD)}_unlockSharedRead(){this._lock(LOCK.SHAREDREAD);if(--this.maplock[LOCK.READERS]==0)this._unlock(LOCK.READLOCK);this._unlock(LOCK.SHAREDREAD)}_lockSharedWrite(){this._lockSharedRead();this._lock(LOCK.SHAREDWRITE);if(++this.maplock[LOCK.WRITERS]==1)this._lock(LOCK.WRITELOCK);this._unlock(LOCK.SHAREDWRITE)}_unlockSharedWrite(){this._lock(LOCK.SHAREDWRITE);if(--this.maplock[LOCK.WRITERS]==0)this._unlock(LOCK.WRITELOCK);this._unlock(LOCK.SHAREDWRITE);this._unlockSharedRead()}lockWrite(){this._lockSharedRead();this._lock(LOCK.WRITELOCK)}unlockWrite(){this._unlock(LOCK.WRITELOCK);this._unlockSharedRead()}_match(key,pos){let i;for(i=0;i<key.length;i++)if(this.keysData[pos*this.meta[META.keySize]+i]!==key.charCodeAt(i))break;return i===key.length&&this.keysData[pos*this.meta[META.keySize]+i]===0}_decodeValue(pos){const eos=this.valuesData.subarray(pos*this.meta[META.objSize],(pos+1)*this.meta[META.objSize]).findIndex(x=>x===0);const end=eos<0?(pos+1)*this.meta[META.objSize]:pos*this.meta[META.objSize]+eos;return String.fromCharCode.apply(null,this.valuesData.subarray(pos*this.meta[META.objSize],end))}_decodeKey(pos){const eos=this.keysData.subarray(pos*this.meta[META.keySize],(pos+1)*this.meta[META.keySize]).findIndex(x=>x===0);const end=eos<0?(pos+1)*this.meta[META.keySize]:pos*this.meta[META.keySize]+eos;return String.fromCharCode.apply(null,this.keysData.subarray(pos*this.meta[META.keySize],end))}_decodeBucket(pos,n){return`pos: ${pos}`+` hash: ${this._hash(this._decodeKey(pos))}`+` key: ${this._decodeKey(pos)}`+` value: ${this._decodeValue(pos)}`+` chain: ${this.chaining[pos]}`+(n>0&&this.chaining[pos]!==UINT32_UNDEFINED?"\n"+this._decodeBucket(this.chaining[pos],n-1):"")}__printMap(){for(let i=0;i<this.meta[META.maxSize];i++)console.log(this._decodeBucket(i,0));process.exit(1)}_write(pos,key,value){let i;for(i=0;i<key.length;i++)this.keysData[pos*this.meta[META.keySize]+i]=key.charCodeAt(i);this.keysData[pos*this.meta[META.keySize]+i]=0;for(i=0;i<value.length;i++)this.valuesData[pos*this.meta[META.objSize]+i]=value.charCodeAt(i);this.valuesData[pos*this.meta[META.objSize]+i]=0}_set(key,value,exclusive){let pos=this._hash(key);if(Atomics.load(this.meta,META.length)===this.meta[META.maxSize])if(!this._find(key,exclusive))throw new RangeError("SharedMap is full");let toChain;let slidingLock;exclusive||(slidingLock=this._lockLine(pos,exclusive));try{while(this.keysData[pos*this.meta[META.keySize]]!==0){this.stats.collisions++;if(this._match(key,pos)){for(let i=0;i<value.length;i++)this.valuesData[pos*this.meta[META.objSize]+i]=value.charCodeAt(i);exclusive||this._unlockLine(slidingLock);return}if(this.chaining[pos]===UINT32_UNDEFINED||toChain!==undefined){if(toChain==undefined){toChain=pos;pos=(pos+1)%this.meta[META.maxSize];exclusive||(slidingLock=this._lockLine(pos))}else{pos=(pos+1)%this.meta[META.maxSize];exclusive||(slidingLock=this._lockLineSliding(slidingLock,pos))}}else{pos=this.chaining[pos];exclusive||(slidingLock=this._lockLineSliding(slidingLock,pos))}}this._write(pos,key,value);this.chaining[pos]=UINT32_UNDEFINED;Atomics.add(this.meta,META.length,1);if(toChain!==undefined){this.chaining[toChain]=pos;exclusive||this._unlockLine(toChain);toChain=undefined}exclusive||this._unlockLine(slidingLock)}catch(e){if(!exclusive){this._unlockLine(slidingLock);if(toChain!==undefined)this._unlockLine(toChain)}throw e}}set(key,value,opt){if(typeof key!=="string"||key.length===0)throw new TypeError(`SharedMap keys must be non-emptry strings, invalid key ${key}`);if(typeof value==="number")value=value.toString();if(typeof value!=="string")throw new TypeError("SharedMap can contain only strings and numbers which will be converted to strings");if(key.length>this.meta[META.keySize])throw new RangeError(`SharedMap key ${key} does not fit in ${this.meta[META.keySize]*Uint16Array.BYTES_PER_ELEMENT} bytes, ${this.meta[META.keySize]} UTF-16 code points`);if(value.length>this.meta[META.objSize])throw new RangeError(`SharedMap value ${value} does not fit in ${this.meta[META.objSize]*Uint16Array.BYTES_PER_ELEMENT} bytes, ${this.meta[META.objSize]} UTF-16 code points`);const lockHeld=opt&&(opt.lockWrite||opt.lockExclusive);this.stats.set++;lockHeld||this._lockSharedWrite();try{this._set(key,value,lockHeld);lockHeld||this._unlockSharedWrite()}catch(e){lockHeld||this._unlockSharedWrite();if(e instanceof Deadlock&&!lockHeld){this.lockExclusive();this.stats.deadlock++;try{this._set(key,value,true);this.unlockExclusive()}catch(e){this.unlockExclusive();throw e}}else throw e}}_find(key,exclusive){let slidingLock;try{let pos=this._hash(key);let previous=UINT32_UNDEFINED;this.stats.get++;exclusive||(slidingLock=this._lockLine(pos));while(pos!==UINT32_UNDEFINED&&this.keysData[pos*this.meta[META.keySize]]!==0){if(this._match(key,pos)){return{pos:pos,previous:previous}}previous=pos;pos=this.chaining[pos];if(pos!==UINT32_UNDEFINED&&!exclusive)slidingLock=this._lockLineSliding(slidingLock,pos)}exclusive||this._unlockLine(slidingLock);return undefined}catch(e){exclusive||this._unlockLine(slidingLock);throw e}}get(key,opt){let pos,val;const lockHeld=opt&&(opt.lockWrite||opt.lockExclusive);lockHeld||this._lockSharedRead();try{pos=this._find(key,lockHeld);if(pos!==undefined){val=this._decodeValue(pos.pos);lockHeld||this._unlockLine(pos.pos)}lockHeld||this._unlockSharedRead()}catch(e){lockHeld||this._unlockSharedRead();if(e instanceof Deadlock&&!lockHeld){this.lockExclusive();this.stats.deadlock++;try{pos=this._find(key,true);if(pos!==undefined){val=this._decodeValue(pos.pos)}this.unlockExclusive()}catch(e){this.unlockExclusive();throw e}}else throw e}return val}has(key,opt){return this.get(key,opt)!==undefined}_hash(s){if(typeof s.hash==="function")return s.hash(s)%this.meta[META.maxSize];if(typeof s.hash==="number")return s.hash%this.meta[META.maxSize];else return _hash(s)%this.meta[META.maxSize]}delete(key,opt){const lockHeld=opt&&opt.lockExclusive;if(opt&&opt.lockWrite&&!lockHeld){throw new Error("delete requires an exclusive lock")}let find;try{lockHeld||this.lockExclusive();find=this._find(key,true)}catch(e){lockHeld||this.unlockExclusive();throw e}if(find===undefined){lockHeld||this.unlockExclusive();throw new RangeError(`SharedMap does not contain key ${key}`)}this.stats.delete++;const{pos:pos,previous:previous}=find;const next=this.chaining[pos];this.keysData[pos*this.meta[META.keySize]]=0;if(previous!==UINT32_UNDEFINED)this.chaining[previous]=UINT32_UNDEFINED;Atomics.sub(this.meta,META.length,1);if(next===UINT32_UNDEFINED){lockHeld||this.unlockExclusive();return}this.stats.rechains++;let el=next;let chain=[];while(el!==UINT32_UNDEFINED){chain.push({key:this._decodeKey(el),value:this._decodeValue(el)});this.keysData[el*this.meta[META.keySize]]=0;Atomics.sub(this.meta,META.length,1);el=this.chaining[el]}for(el of chain){this._set(el.key,el.value,true)}lockHeld||this.unlockExclusive()}*_keys(exclusive){for(let pos=0;pos<this.meta[META.maxSize];pos++){exclusive||this._lockSharedRead();exclusive||this._lockLine(pos);if(this.keysData[pos*this.meta[META.keySize]]!==0){yield pos}else{exclusive||this._unlockLine(pos);exclusive||this._unlockSharedRead()}}}*keys(opt){const lockHeld=opt&&(opt.lockWrite||opt.lockExclusive);for(let pos of this._keys(lockHeld)){const k=this._decodeKey(pos);lockHeld||this._unlockLine(pos);lockHeld||this._unlockSharedRead();yield k}}map(cb,thisArg){const a=[];for(let pos of this._keys()){const k=this._decodeKey(pos);const v=this._decodeValue(pos);try{a.push(cb.call(thisArg,v,k));this._unlockLine(pos);this._unlockSharedRead()}catch(e){this._unlockLine(pos);this._unlockSharedRead();throw e}}return a}reduce(cb,initialValue){let a=initialValue;for(let pos of this._keys(false)){const k=this._decodeKey(pos);const v=this._decodeValue(pos);try{a=cb(a,v,k);this._unlockLine(pos);this._unlockSharedRead()}catch(e){this._unlockLine(pos);this._unlockSharedRead();throw e}}return a}clear(){this.lockExclusive();this.keysData.fill(0);this.valuesData.fill(0);Atomics.store(this.meta,META.length,0);this.unlockExclusive()}}module.exports=SharedMap;